# Работа с индексами, join'ами, статистикой. Отчет по ДЗ.

## 1. Выполним подготовительные работы

### 1.1 Создадим ВМ в GCP в конфигурации e2-medium (2 CPU, 4GB RAM), 20 GB SDD.

```

C:\Program Files (x86)\Google\Cloud SDK>gcloud compute instances create instance-14 --project=postgres2021-lobach-02 --zone=us-central1-c --machine-type=e2-medium --network-interface=network-tier=PREMIUM,subnet=default --maintenance-policy=MIGRATE --service-account=180845300769-compute@developer.gserviceaccount.com --scopes=https://www.googleapis.com/auth/devstorage.read_only,https://www.googleapis.com/auth/logging.write,https://www.googleapis.com/auth/monitoring.write,https://www.googleapis.com/auth/servicecontrol,https://www.googleapis.com/auth/service.management.readonly,https://www.googleapis.com/auth/trace.append --create-disk=auto-delete=yes,boot=yes,device-name=instance-14,image=projects/ubuntu-os-cloud/global/images/ubuntu-2004-focal-v20220110,mode=rw,size=20,type=projects/postgres2021-lobach-02/zones/us-central1-c/diskTypes/pd-ssd --no-shielded-secure-boot --shielded-vtpm --shielded-integrity-monitoring --reservation-affinity=any

Created [https://www.googleapis.com/compute/v1/projects/postgres2021-lobach-02/zones/us-central1-c/instances/instance-14].

WARNING: Some requests generated warnings:

- Disk size: '20 GB' is larger than image size: '10 GB'. You might need to resize the root repartition manually if the operating system does not support automatic resizing. See https://cloud.google.com/compute/docs/disks/add-persistent-disk#resize_pd for details.

 

NAME         ZONE           MACHINE_TYPE  PREEMPTIBLE  INTERNAL_IP  EXTERNAL_IP    STATUS

instance-14  us-central1-c  e2-medium                  10.128.0.16  34.132.75.180  RUNNING

```

 

### 1.2 Установим и настроим Postgresql 14

#### 1.2.1 Выполним установку Postgresql 14

``` console

 

User@instance-14:~$sudo sudo sh -c 'echo "deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" > /etc/apt/sources.list.d/pgdg.list' && wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add - && sudo apt -y update &&  sudo apt -y install postgresql-14

 

User@instance-14:~$ sudo pg_lsclusters

Ver Cluster Port Status Owner    Data directory              Log file

14  main    5432 online postgres /var/lib/postgresql/14/main /var/log/postgresql/postgresql-14-main.log

 

```

#### 1.2.2 Выполним настройку по рекомендуемым параметрам

```

# DB Version: 14

# OS Type: linux

# DB Type: oltp

# Total Memory (RAM): 4 GB

# CPUs num: 4

# Connections num: 20

# Data Storage: ssd

 

max_connections = 20

shared_buffers = 1GB

effective_cache_size = 3GB

maintenance_work_mem = 256MB

checkpoint_completion_target = 0.9

wal_buffers = 16MB

default_statistics_target = 100

random_page_cost = 1.1

effective_io_concurrency = 200

work_mem = 26214kB

min_wal_size = 2GB

max_wal_size = 8GB

max_worker_processes = 4

max_parallel_workers_per_gather = 2

max_parallel_workers = 4

max_parallel_maintenance_workers = 2

```

### 1.3 Скачаем и развернем тестовую БД (https://postgrespro.com/education/demodb)

```console

User@instance-14:~$ sudo su postgres

postgres@instance-14:/home/User$ mkdir /tmp/sample_data

postgres@instance-14:/home/User$ cd /tmp/sample_data/

 

postgres@instance-14:/tmp/sample_data$ wget https://edu.postgrespro.com/demo-big-en.zip

--2022-01-15 19:52:29--  https://edu.postgrespro.com/demo-big-en.zip

Resolving edu.postgrespro.com (edu.postgrespro.com)... 93.174.131.139

Connecting to edu.postgrespro.com (edu.postgrespro.com)|93.174.131.139|:443... connected.

HTTP request sent, awaiting response... 200 OK

Length: 243203220 (232M) [application/zip]

Saving to: ‘demo-big-en.zip’

 

demo-big-en.zip     100%[===================>] 231.94M  10.2MB/s    in 25s

 

2022-01-15 19:52:55 (9.43 MB/s) - ‘demo-big-en.zip’ saved [243203220/243203220]

 

postgres@instance-14:/tmp/sample_data$ unzip demo-big-en.zip

Archive:  demo-big-en.zip

  inflating: demo-big-en-20170815.sql

 

 postgres@instance-14: psql < demo-big-en-20170815.sql

 

 

```

### 1.4 Подключимся к БД. Проверим объем добавленных данных

```

postgres=# \l

 

                              List of databases

   Name    |  Owner   | Encoding | Collate |  Ctype  |   Access privileges 

-----------+----------+----------+---------+---------+-----------------------

demo      | postgres | UTF8     | C.UTF-8 | C.UTF-8 |

postgres  | postgres | UTF8     | C.UTF-8 | C.UTF-8 |

template0 | postgres | UTF8     | C.UTF-8 | C.UTF-8 | =c/postgres          +

           |          |          |         |         | postgres=CTc/postgres

template1 | postgres | UTF8     | C.UTF-8 | C.UTF-8 | =c/postgres          +

           |          |          |         |         | postgres=CTc/postgres

(4 rows)

 

```

```

postgres=# \c demo

You are now connected to database "demo" as user "postgres".

demo=# \dt+

                                                List of relations

  Schema  |      Name       | Type  |  Owner   | Persistence | Access method |  Size  |        Description   

----------+-----------------+-------+----------+-------------+---------------+--------+---------------------------

bookings | aircrafts_data  | table | postgres | permanent   | heap          | 16 kB  | Aircrafts (internal data)

bookings | airports_data   | table | postgres | permanent   | heap          | 56 kB  | Airports (internal data)

bookings | boarding_passes | table | postgres | permanent   | heap          | 455 MB | Boarding passes

bookings | bookings        | table | postgres | permanent   | heap          | 105 MB | Bookings

bookings | flights         | table | postgres | permanent   | heap          | 21 MB  | Flights

bookings | seats           | table | postgres | permanent   | heap          | 96 kB  | Seats

bookings | ticket_flights  | table | postgres | permanent   | heap          | 547 MB | Flight segment

bookings | tickets         | table | postgres | permanent   | heap          | 386 MB | Tickets

(8 rows)

 

```

Посмотрим на существующие индексы:

```

demo=# \di+

                                                                List of relations

  Schema  |                   Name                    | Type  |  Owner   |      Table      | Persistence | Access method |  Size   | Description

----------+-------------------------------------------+-------+----------+-----------------+-------------+---------------+---------+-------------

bookings | aircrafts_pkey                            | index | postgres | aircrafts_data  | permanent   | btree         | 16 kB   |

bookings | airports_data_pkey                        | index | postgres | airports_data   | permanent   | btree         | 16 kB   |

bookings | boarding_passes_flight_id_boarding_no_key | index | postgres | boarding_passes | permanent   | btree         | 170 MB  |

bookings | boarding_passes_flight_id_seat_no_key     | index | postgres | boarding_passes | permanent   | btree         | 170 MB  |

bookings | boarding_passes_pkey                      | index | postgres | boarding_passes | permanent   | btree         | 307 MB  |

bookings | bookings_pkey                             | index | postgres | bookings        | permanent   | btree         | 45 MB   |

bookings | flights_flight_no_scheduled_departure_key | index | postgres | flights         | permanent   | btree         | 6648 kB |

bookings | flights_pkey                              | index | postgres | flights         | permanent   | btree         | 4744 kB |

bookings | seats_pkey                                | index | postgres | seats           | permanent   | btree         | 48 kB   |

bookings | ticket_flights_pkey                       | index | postgres | ticket_flights  | permanent   | btree         | 325 MB  |

bookings | tickets_pkey                              | index | postgres | tickets         | permanent   | btree         | 89 MB   |

(11 rows)

```

 

## 2. Вариант 1

### 2.1 Создать индекс к какой-либо из таблиц вашей БД

### 2.1.1 Проведем предварительный анализ работы тестового запроса

```

demo=# explain(analyze) select * from flights where aircraft_code ='SU9';

                                          QUERY PLAN                   

--------------------------------------------------------------------------------------------------------------

Seq Scan on flights  (cost=0.00..5309.84 rows=54999 width=63) (actual time=0.019..33.982 rows=55213 loops=1)

   Filter: (aircraft_code = 'SU9'::bpchar)

   Rows Removed by Filter: 159654

Planning Time: 0.114 ms

Execution Time: 35.897 ms

(5 rows)

 

```

**Анализ:**

При выполнении тестового запроса используется последовательное сканирование таблицы,следовательно производительность можно попробовать улучшить, за счет использовани индекса

 

### 2.1.2 Проведем анализ селективности запроса при фильтрации по полю aircraft_code

```

demo=# select * from pg_stats where tablename ='flights' and attname = 'aircraft_code';

-[ RECORD 1 ]----------+-------------------------------------------------------------------------------

schemaname             | bookings

tablename              | flights

attname                | aircraft_code

inherited              | f

null_frac              | 0

avg_width              | 4

n_distinct             | 8

most_common_vals       | {CN1,CR2,SU9,321,319,763,733,773}

most_common_freqs      | {0.2835,0.27086666,0.25596666,0.05776667,0.039,0.0379,0.036733333,0.018266667}

histogram_bounds       |

correlation            | 0.3182364

most_common_elems      |

most_common_elem_freqs |

elem_count_histogram   |

 

```

Исходя из статистики по частоте распределения значений,видно что использование значения "SU9" при фильтрации обеспечивает хорошую селективность.

Следовательно можно сделать вывод о потенциальной эффективности применения индекса для конкретного случая - запрос с фильтрацией по полю aircraft_code со значением 'SU9'

 

### 2.1.3 Создадим btree-индекс по полю aircraft_code

```sql

demo=# create index on flights using btree(aircraft_code);

 

CREATE INDEX

```

### 2.2 Прислать текстом результат команды explain, в которой используется данный индекс

```sql

explain(analyze) select * from flights where aircraft_code ='SU9';

 

                                                                  QUERY PLAN   

-----------------------------------------------------------------------------------------------------------------------------------------------

Index Scan using flights_aircraft_code_idx on flights  (cost=0.29..3677.73 rows=54999 width=63) (actual time=0.033..9.297 rows=55213 loops=1)

   Index Cond: (aircraft_code = 'SU9'::bpchar)

Planning Time: 0.649 ms

Execution Time: 11.275 ms

(4 rows)

 

```

**Анализ:** Запрос выполняется за счет сканирования по индексу. Скорость вполнения запроса увеличилась в 35.897/11.275=3.18 раз.

### 2.3 Реализовать индекс для полнотекстового поиска

#### 2.3.1 Выполним поиск пассажиров с заданным именем и фамилией по таблице tickets:

```

demo=# \d+ tickets;

ticket_no      | character(13)         |           | not null |         | extended |             |              | Ticket number

book_ref       | character(6)          |           | not null |         | extended |             |              | Booking number

passenger_id   | character varying(20) |           | not null |         | extended |             |              | Passenger ID

passenger_name | text                  |           | not null |         | extended |             |              | Passenger name

contact_data   | jsonb  

```

#### 2.3.2 Оценим общее количество записей в таблице tickets

```sql

demo=# select count(*) from tickets;

2949857

 

Time: 461.384 ms

 

```

Имеем достаточно большое количество записей для проведения анализа эффективности работы полнотекстового поиска.

 

#### 2.3.3 Выполним анализ запроса по выборке количества пассажиров с заданным именем и фамилией

```sql

demo=# explain (analyze) select * from tickets where passenger_name like 'ILYA%' and (passenger_name like  '%PETROV' or passenger_name like '%PAVLOV');

                                                              QUERY PLAN       

--------------------------------------------------------------------------------------------------------------------------------------

Gather  (cost=1000.00..85320.97 rows=6 width=140) (actual time=0.966..3214.549 rows=698 loops=1)

   Workers Planned: 2

   Workers Launched: 2

   ->  Parallel Seq Scan on tickets  (cost=0.00..84320.37 rows=2 width=140) (actual time=0.347..3203.709 rows=233 loops=3)

         Filter: ((passenger_name ~~ 'ILYA%'::text) AND ((passenger_name ~~ '%PETROV'::text) OR (passenger_name ~~ '%PAVLOV'::text)))

         Rows Removed by Filter: 983053

Planning Time: 0.231 ms

Execution Time: 3214.876 ms

(8 rows)

 

**Анализ:** Запрос выполняется путем последовательного сканирования таблицы, с фильтрацией по заданному логическому выражению. Сканирование выполняется параллельно в двух процессах.

 

```

#### 2.3.4 Оценим эффективность использования btree-индекса c классом операторов text_pattern_ops для выборки

##### 2.3.4.1 Создадим btree-индекс

```sql

demo=# create index name_btree on tickets using btree(passenger_name text_pattern_ops);

CREATE INDEX

Time: 4520.187 ms (00:04.520)

 

```

##### 2.3.4.2 Выполним анализ плана выполнения запроса с использованием btree-индекса

```sql

explain (analyze) select * from tickets where passenger_name like 'ILYA%' and (passenger_name like  '%PETROV' or passenger_name like '%PAVLOV');

 

                                                           QUERY PLAN          

--------------------------------------------------------------------------------------------------------------------------------

Index Scan using name_btree on tickets  (cost=0.43..2.66 rows=6 width=140) (actual time=17.553..27.778 rows=698 loops=1)

   Index Cond: ((passenger_name ~>=~ 'ILYA'::text) AND (passenger_name ~<~ 'ILYB'::text))

   Filter: ((passenger_name ~~ 'ILYA%'::text) AND ((passenger_name ~~ '%PETROV'::text) OR (passenger_name ~~ '%PAVLOV'::text)))

   Rows Removed by Filter: 16343

Planning Time: 0.251 ms

Execution Time: 27.850 ms

(6 rows)

 

```

**Анализ:** Запрос выполняется за счет сканирования по btree-индексу и предварительной фильтрацией. Скорость вполнения запроса увеличилась в 3214.876/27.850=115.43 раз.

##### 2.3.4.3 Оценим количество записей в выборке при выполнении запроса с использованием btree-индекса

```sql

demo=# select count(*) from tickets where passenger_name like 'ILYA%' and (passenger_name like  '%PETROV' or passenger_name like '%PAVLOV');

count

-------

   698

(1 row)

 

Time: 25.487 ms

```

 

#### 2.3.5 Оценим эффективность использования gist-индекса

##### 2.3.5.1 Выполним преобразование набора данных к формату tsvector

```sql

demo=# alter table tickets add column name_tsv tsvector;

ALTER TABLE

 

demo=# update tickets set name_tsv = to_tsvector('english', tickets.passenger_name);

UPDATE 2949857

```

##### 2.3.5.2 Создадим gist-индекс

```sql

demo=# create index name_gist on tickets using gist(name_tsv);

CREATE INDEX

Time: 83471.319 ms (01:23.471)

 

```

 

##### 2.3.5.3 Выполним анализ плана выполнения запроса с использованием gist-индекса

```sql

explain(analyze) select * from tickets where name_tsv @@ to_tsquery('ILYA & (PAVLOV | PETROV)');

 

                                                         QUERY PLAN            

----------------------------------------------------------------------------------------------------------------------------

Index Scan using name_gist on tickets  (cost=0.66..351.52 rows=312 width=140) (actual time=0.246..86.896 rows=698 loops=1)

   Index Cond: (name_tsv @@ to_tsquery('ILYA & (PAVLOV | PETROV)'::text))

Planning Time: 0.214 ms

Execution Time: 86.965 ms

(4 rows)

```

**Анализ:** Запрос выполняется за счет сканирования по gist-индексу. Скорость вполнения запроса увеличилась в  3214.876/86.965 = 36.97 раз, что по

сравнению с запросом на базе btree-индекса в 115.43/36.97=3.12 раз медленнее. Данное обстоятельство можно объяснить относительно небольшим размером тестовых данных - вероятно

при запросе достаточно опреативной памяти для обработки. В этом случае эффективность gist-индекса уступает btree-индексу.

 

##### 2.3.5.4 Оценим количество записей в выборке при выполнении запроса с использованием gist-индекса

```sql

demo=# select count(*) from tickets where name_tsv @@ to_tsquery('ILYA & (PAVLOV | PETROV)');

count

-------

   698

(1 row)

 

Time: 279.011 ms

 

```

#### 2.3.6 Оценим эффективность использования gin-индекса

##### 2.3.6.1 Создадим gin-индекс

```sql

demo=# create index name_gin on tickets using gin(name_tsv);

CREATE INDEX

Time: 4006.936 ms (00:04.007)

 

```

 

##### 2.3.6.2 Выполним анализ плана выполнения запроса с использованием gin-индекса

```sql

demo=# explain(analyze) select * from tickets where name_tsv @@ to_tsquery('ILYA & (PAVLOV | PETROV)');

 

                                                      QUERY PLAN               

----------------------------------------------------------------------------------------------------------------------

Bitmap Heap Scan on tickets  (cost=21.37..444.27 rows=312 width=140) (actual time=3.272..4.087 rows=698 loops=1)

   Recheck Cond: (name_tsv @@ to_tsquery('ILYA & (PAVLOV | PETROV)'::text))

   Heap Blocks: exact=694

   ->  Bitmap Index Scan on name_gin  (cost=0.00..21.29 rows=312 width=0) (actual time=3.160..3.161 rows=698 loops=1)

         Index Cond: (name_tsv @@ to_tsquery('ILYA & (PAVLOV | PETROV)'::text))

Planning Time: 0.287 ms

Execution Time: 4.191 ms

(7 rows)

 

```

**Анализ:** Запрос выполняется за счет сканирования по gin-индексу, с последующей проверкой выборки по битовой карте. Скорость вполнения запроса увеличилась в 3214.876/4.191 = 767.09 раз, что по

сравнению с запросом на базе btree-индекса в 767.09/115.43 = 6.65 раз быстрее и по сравнению с запросом на базе gist-индекса в 767.09/36.97=20.75 раз быстре.

 

#### 2.3.7 Оценим размер, занимаемый разными типами индексов для полноткстового поиска

##### 2.3.7.1 Выполним вакуум

```sql

demo=# vacuum full ;

VACUUM

Time: 324701.446 ms (05:24.701)

```

 

##### 2.3.7.2 Выполним оценку размера разных типов индекса

```

select pg_size_pretty(pg_relation_size('name_gin')) as gin,

             pg_size_pretty(pg_relation_size('name_gist')) as gist,

             pg_size_pretty(pg_relation_size('name_btree')) as btree;

                                           

  gin  |  gist  | btree

-------+--------+-------

15 MB | 105 MB | 21 MB

(1 row)

 

```

**Анализ:** Размер gin-индекса для тестового  набора данных меньше, чем размер gist-индекса и btree-индекса.

 

### 2.4 Реализовать индекс на часть таблицы или индекс на поле с функцией

#### 2.4.1 Создадим индекс на часть таблицы flights

```sql

demo=# create index flights_partial_idx on flights using btree(aircraft_code) where aircraft_code ='SU9';

CREATE INDEX

Time: 103.165 ms

```

#### 2.4.2 Оценим размер частичного и полного индекса по таблице

```sql

demo=#select pg_size_pretty(pg_relation_size('flights_aircraft_code_idx')) as flights_btree_full,

                                                                          pg_size_pretty(pg_relation_size('partial_index_flights')) as flights_btree_partial;

                                                                                        

flights_btree_full  | flights_btree_partial

--------------------+-----------------------

1472 kB            | 392 kB

(1 row)

 

```                                       

#### 2.4.3 Выполним анализ плана выполнения запроса с использованием частичного индекса

```sql

demo=# explain(analyze) select * from flights where aircraft_code ='SU9';

                                                               QUERY PLAN

-----------------------------------------------------------------------------------------------------------------------------------------

Index Scan using flights_partial_idx on flights  (cost=0.29..3541.32 rows=54999 width=63) (actual time=0.020..9.485 rows=55213 loops=1)

Planning Time: 16.720 ms

Execution Time: 12.733 ms

(3 rows)

 

Time: 30.042 ms

 

```

 

**Анализ:** Запрос выполняется с использованием индекса на часть таблицы. Скорость выполнения запроса по сравнению с запросом, при котором использовался индекс по всей таблице

практически не изменилась (см. п.2.2), однако полный индекс занимает существенно больше места на диске (см. п.2.4.2).

 

### 2.5 Создать индекс на несколько полей

#### 2.5.1 Выполним анализ плана выполнения запроса с использованием  простого btree-индекса 

```sql

demo=# explain(analyze) select * from flights where aircraft_code ='SU9' and arrival_airport='URS';

                                                                 QUERY PLAN

--------------------------------------------------------------------------------------------------------------------------------------------

Index Scan using flights_aircraft_code_idx on flights  (cost=0.29..3815.22 rows=244 width=63) (actual time=1.517..16.520 rows=396 loops=1)

   Index Cond: (aircraft_code = 'SU9'::bpchar)

   Filter: (arrival_airport = 'URS'::bpchar)

   Rows Removed by Filter: 54817

Planning Time: 6.630 ms

Execution Time: 16.593 ms

(6 rows)

 

```

**Анализ** При выполнении запроса используется btree-индекс по полю aircraft_code,  с предварительной фильтрацией данных по полю arrival_airport

 

### 2.5.2 Создадим составной индекс

```sql

demo=# create index flights_complex_idx on flights using btree(aircraft_code,arrival_airport);

CREATE INDEX

Time: 411.521 ms

```

#### 2.5.3 Выполним анализ плана выполнения запроса с использованием составного индекса 

```sql

demo=# explain(analyze) select * from flights where aircraft_code ='SU9' and arrival_airport='URS';

                                                             QUERY PLAN

------------------------------------------------------------------------------------------------------------------------------------

Index Scan using flights_complex_idx on flights  (cost=0.29..249.19 rows=244 width=63) (actual time=0.023..0.089 rows=396 loops=1)

   Index Cond: ((aircraft_code = 'SU9'::bpchar) AND (arrival_airport = 'URS'::bpchar))

Planning Time: 0.236 ms

Execution Time: 0.137 ms

(4 rows)

 

Time: 0.814 ms

 

```

**Анализ** При выполнении запроса используется составной btree-индекс. Время выполнения запроса сократилось в 16.593/0.137 = 121,12 раз (см. п.2.5.1).

 

### 2.6 Материалы

 

<https://habr.com/ru/company/postgrespro/blog/326096/>

<https://eax.me/postgresql-full-text-search/>

<https://eax.me/pg-trgm/>

<https://eax.me/regular-expr/>

<https://postgrespro.ru/education/demodb>

<https://oc.postgrespro.ru/index.php/s/fRxTZ0sVfPZzbmd>

 

 

## 3. Вариант 2

### 3.1 Реализовать прямое соединение двух или более таблиц

#### 3.1.1 Выберем имя, номер телефона пассажира и дату бронирования из таблиц tickets и bookings

```sql

demo=# select t.passenger_name, t.contact_data->> 'phone' as phone, b.book_date from tickets t inner join  bookings b on t.book_ref = b.book_ref

-[ RECORD 1 ]--+-----------------------

passenger_name | MIKHAIL SEMENOV

phone          | +70110137563

book_date      | 2016-08-01 05:07:00+00

-[ RECORD 2 ]--+-----------------------

passenger_name | ELENA ZAKHAROVA

phone          | +70670013989

book_date      | 2016-08-05 08:05:00+00

...

```

#### 3.1.2 Выполним анализ плана выполнения запроса

```sql

demo=# explain (analyze) select t.passenger_name, t.contact_data->> 'phone' as phone, b.book_date from tickets t inner join  bookings b on t.book_ref = b.book_ref;

                                                            QUERY PLAN

-----------------------------------------------------------------------------------------------------------------------------------

Hash Join  (cost=71255.98..250493.09 rows=2949759 width=56) (actual time=668.569..3827.235 rows=2949857 loops=1)

   Hash Cond: (t.book_ref = b.book_ref)

   ->  Seq Scan on tickets t  (cost=0.00..78912.59 rows=2949759 width=78) (actual time=6.512..558.616 rows=2949857 loops=1)

   ->  Hash  (cost=34558.10..34558.10 rows=2111110 width=15) (actual time=661.055..661.056 rows=2111110 loops=1)

         Buckets: 131072  Batches: 64  Memory Usage: 2537kB

         ->  Seq Scan on bookings b  (cost=0.00..34558.10 rows=2111110 width=15) (actual time=0.019..257.070 rows=2111110 loops=1)

Planning Time: 0.196 ms

JIT:

   Functions: 10

   Options: Inlining false, Optimization false, Expressions true, Deforming true

   Timing: Generation 1.271 ms, Inlining 0.000 ms, Optimization 1.028 ms, Emission 5.199 ms, Total 7.498 ms

Execution Time: 3930.481 ms

(12 rows)

```

Time: 3931.207 ms (00:03.931)

**Анализ:** Для выполнения запроса используется git-компиляция, для объединения таблиц в запросе используется механизм слияния хэшированием.

 

### 3.2 Реализовать левостороннее (или правостороннее) соединение двух или более таблиц

#### 3.2.1 Выберем все записи  по бронированиям, для которых время бронирования совпадает с запланированным временем вылета

```sql

demo=#  select * from bookings b left join flights f on b.book_date= f.scheduled_departure where  scheduled_departure is not null;

-[ RECORD 1 ]-------+-----------------------

book_ref            | 000010

book_date           | 2017-01-08 16:45:00+00

total_amount        | 50900.00

flight_id           | 194769

flight_no           | PG0386

scheduled_departure | 2017-01-08 16:45:00+00

scheduled_arrival   | 2017-01-08 17:15:00+00

departure_airport   | BZK

arrival_airport     | DME

status              | Arrived

aircraft_code       | SU9

actual_departure    | 2017-01-08 19:24:00+00

actual_arrival      | 2017-01-08 19:54:00+00

 

Time: 40.521 ms

...

```

#### 3.2.1 Выполним анализ плана выполнения запроса

```sql

demo=# explain (analyze, verbose) select * from bookings b left join flights f on b.book_date= f.scheduled_departure where  scheduled_departure is not null;                                                                                                          QUERY PLAN                                       

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Hash Join  (cost=9767.51..97379.56 rows=1017163 width=84) (actual time=69.773..1251.206 rows=761204 loops=1)

   Output: b.book_ref, b.book_date, b.total_amount, f.flight_id, f.flight_no, f.scheduled_departure, f.scheduled_arrival, f.departure_airport, f.arrival_airport, f.status, f.aircraft_code, f.actual_departure, f.actual_arrival

   Hash Cond: (b.book_date = f.scheduled_departure)

   ->  Seq Scan on bookings.bookings b  (cost=0.00..34558.10 rows=2111110 width=21) (actual time=0.011..182.005 rows=2111110 loops=1)

         Output: b.book_ref, b.book_date, b.total_amount

   ->  Hash  (cost=4772.67..4772.67 rows=214867 width=63) (actual time=69.537..69.539 rows=214867 loops=1)

         Output: f.flight_id, f.flight_no, f.scheduled_departure, f.scheduled_arrival, f.departure_airport, f.arrival_airport, f.status, f.aircraft_code, f.actual_departure, f.actual_arrival

         Buckets: 65536  Batches: 8  Memory Usage: 3180kB

         ->  Seq Scan on bookings.flights f  (cost=0.00..4772.67 rows=214867 width=63) (actual time=0.007..26.767 rows=214867 loops=1)

               Output: f.flight_id, f.flight_no, f.scheduled_departure, f.scheduled_arrival, f.departure_airport, f.arrival_airport, f.status, f.aircraft_code, f.actual_departure, f.actual_arrival

               Filter: (f.scheduled_departure IS NOT NULL)

Planning Time: 0.148 ms

Execution Time: 1277.956 ms

(13 rows)

 

```

**Анализ:** Для выполнения запроса используется последовательное сканирование таблиц, для объединения таблиц в запросе используется механизм слияния хэшированием.

 

### 3.3 Реализовать кросс соединение двух или более таблиц

#### 3.3.1 Выполним кросс соединение таблицы flights и таблицы aircrafts

```sql

demo=# select * from flights f cross join aircrafts limit 1;

-[ RECORD 1 ]-------+-----------------------

flight_id           | 2880

flight_no           | PG0216

scheduled_departure | 2017-09-14 11:10:00+00

scheduled_arrival   | 2017-09-14 12:15:00+00

departure_airport   | DME

arrival_airport     | KUF

status              | Scheduled

aircraft_code       | 763

actual_departure    |

actual_arrival      |

aircraft_code       | 773

model               | Boeing 777-300

range               | 11100

 

```

#### 3.3.2 Выполним анализ плана выполнения запроса

```sql

demo=# explain (analyze, verbose) select * from flights f cross join aircrafts a;

                                                                                                  QUERY PLAN                                  

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Nested Loop  (cost=0.00..517231.58 rows=1933803 width=115) (actual time=92.524..2861.082 rows=1933803 loops=1)

   Output: f.flight_id, f.flight_no, f.scheduled_departure, f.scheduled_arrival, f.departure_airport, f.arrival_airport, f.status, f.aircraft_code, f.actual_departure, f.actual_arrival, ml.aircraft_code, (ml.model ->> lang()), ml.range

   ->  Seq Scan on bookings.flights f  (cost=0.00..4772.67 rows=214867 width=63) (actual time=0.013..20.529 rows=214867 loops=1)

         Output: f.flight_id, f.flight_no, f.scheduled_departure, f.scheduled_arrival, f.departure_airport, f.arrival_airport, f.status, f.aircraft_code, f.actual_departure, f.actual_arrival

   ->  Materialize  (cost=0.00..1.14 rows=9 width=52) (actual time=0.000..0.001 rows=9 loops=214867)

         Output: ml.aircraft_code, ml.model, ml.range

         ->  Seq Scan on bookings.aircrafts_data ml  (cost=0.00..1.09 rows=9 width=52) (actual time=0.005..0.009 rows=9 loops=1)

               Output: ml.aircraft_code, ml.model, ml.range

Planning Time: 0.439 ms

JIT:

   Functions: 3

   Options: Inlining true, Optimization true, Expressions true, Deforming true

   Timing: Generation 1.597 ms, Inlining 9.213 ms, Optimization 54.517 ms, Emission 28.496 ms, Total 93.823 ms

Execution Time: 2960.651 ms

(14 rows)

 

```

**Анализ:** Для выполнения запроса используется последовательное сканирование таблиц, для объединения таблиц в запросе используется механизм вложенного цикла.

 

### 3.4 Реализовать полное соединение двух или более таблиц

#### 3.4.1 Выполним полное соединение таблицы flights и таблицы aircrafts, за исключением записей с нулевым значением поля aircraft_code

```sql

demo=# select  * from flights f full outer join aircrafts a on f.aircraft_code = a.aircraft_code where a.aircraft_code is not null and  f.aircraft_code is not null;

-[ RECORD 1 ]-------+-----------------------

flight_id           | 2880

flight_no           | PG0216

scheduled_departure | 2017-09-14 11:10:00+00

scheduled_arrival   | 2017-09-14 12:15:00+00

departure_airport   | DME

arrival_airport     | KUF

status              | Scheduled

aircraft_code       | 763

actual_departure    |

actual_arrival      |

aircraft_code       | 763

model               | Boeing 767-300

range               | 7900

-[ RECORD 2 ]-------+-----------------------

flight_id           | 3940

flight_no           | PG0212

scheduled_departure | 2017-09-04 15:20:00+00

scheduled_arrival   | 2017-09-04 16:35:00+00

departure_airport   | DME

arrival_airport     | ROV

status              | Scheduled

aircraft_code       | 321

actual_departure    |

actual_arrival      |

aircraft_code       | 321

model               | Airbus A321-200

range               | 5600

....

```

#### 3.4.2 Выполним анализ плана выполнения запроса

```sql

demo=# explain(analyze, verbose) select  * from flights f full outer join aircrafts a on f.aircraft_code = a.aircraft_code where a.aircraft_code is not null and  f.aircraft_code is not null;

                                                                                                                  QUERY PLAN                                 

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Hash Join  (cost=3.47..5605.77 rows=214867 width=115) (actual time=0.089..89.771 rows=214867 loops=1)

   Output: f.flight_id, f.flight_no, f.scheduled_departure, f.scheduled_arrival, f.departure_airport, f.arrival_airport, f.status, f.aircraft_code, f.actual_departure, f.actual_arrival, ml.aircraft_code, ((ml.model ->> lang())), ml.range

   Inner Unique: true

   Hash Cond: (f.aircraft_code = ml.aircraft_code)

   ->  Seq Scan on bookings.flights f  (cost=0.00..4772.67 rows=214867 width=63) (actual time=0.011..32.327 rows=214867 loops=1)

         Output: f.flight_id, f.flight_no, f.scheduled_departure, f.scheduled_arrival, f.departure_airport, f.arrival_airport, f.status, f.aircraft_code, f.actual_departure, f.actual_arrival

         Filter: (f.aircraft_code IS NOT NULL)

   ->  Hash  (cost=3.36..3.36 rows=9 width=52) (actual time=0.070..0.072 rows=9 loops=1)

         Output: ml.aircraft_code, ml.range, ((ml.model ->> lang()))

         Buckets: 1024  Batches: 1  Memory Usage: 9kB

         ->  Seq Scan on bookings.aircrafts_data ml  (cost=0.00..3.36 rows=9 width=52) (actual time=0.050..0.065 rows=9 loops=1)

               Output: ml.aircraft_code, ml.range, (ml.model ->> lang())

               Filter: (ml.aircraft_code IS NOT NULL)

Planning Time: 0.223 ms

Execution Time: 97.998 ms

 

```

**Анализ:** Для выполнения запроса используется последовательное сканирование таблиц, для объединения таблиц в запросе используется механизм слияния хэшированием.

### 3.5 Реализовать запрос, в котором будут использованы разные типы соединений

#### 3.5.1 Выберем данные, сотвествующие бронированиям выполненным не раньше, чем за 6 дней до вылета по расписанию.

```sql

demo=# select b.book_date, t.passenger_name, tf.fare_conditions, fl.scheduled_departure  from bookings b inner join tickets t on b.book_ref = t.book_ref

inner join ticket_flights tf on t.ticket_no = tf.ticket_no

left join flights fl on date_trunc('day', b.book_date) > date_bin('6 days', fl.scheduled_departure, TIMESTAMP '2001-01-01')

where tf.flight_id = fl.flight_id;

-[ RECORD 1 ]-------+-----------------------

book_date           | 2017-05-14 21:27:00+00

passenger_name      | NINA FEDOROVA

fare_conditions     | Business

scheduled_departure | 2017-05-18 06:45:00+00

-[ RECORD 2 ]-------+-----------------------

book_date           | 2016-11-09 10:30:00+00

passenger_name      | VERA SERGEEVA

fare_conditions     | Economy

scheduled_departure | 2016-11-13 09:10:00+00

-[ RECORD 3 ]-------+-----------------------

book_date           | 2016-10-16 05:36:00+00

passenger_name      | FILIPP SAVELEV

fare_conditions     | Economy

scheduled_departure | 2016-10-20 14:55:00+00

-[ RECORD 4 ]-------+-----------------------

book_date           | 2016-12-27 17:46:00+00

passenger_name      | YURIY SMIRNOV

fare_conditions     | Economy

scheduled_departure | 2016-12-31 07:30:00+00

-[ RECORD 5 ]-------+-----------------------

book_date           | 2017-05-14 21:27:00+00

passenger_name      | NINA FEDOROVA

fare_conditions     | Economy

scheduled_departure | 2017-05-18 16:10:00+00

-[ RECORD 6 ]-------+-----------------------

book_date           | 2016-11-09 10:30:00+00

passenger_name      | ALEKSANDR KRASNOV

fare_conditions     | Economy

scheduled_departure | 2016-11-13 09:10:00+00

 

Time: 16353.698 ms (00:16.354)

 

```

#### 3.5.2 Выполним анализ плана выполнения запроса

```sql

demo=# explain(analyze, verbose)

select b.book_date, t.passenger_name, tf.fare_conditions, fl.scheduled_departure  from bookings b inner join tickets t on b.book_ref = t.book_ref

inner join ticket_flights tf on t.ticket_no = tf.ticket_no

left join flights fl on date_trunc('day', b.book_date) > date_bin('6 days', fl.scheduled_departure, TIMESTAMP '2001-01-01')

where tf.flight_id = fl.flight_id;

   QUERY PLAN                                                                                     

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Gather  (cost=158020.77..692171.37 rows=2797284 width=40) (actual time=15168.188..15957.509 rows=6 loops=1)

   Output: b.book_date, t.passenger_name, tf.fare_conditions, fl.scheduled_departure

   Workers Planned: 2

   Workers Launched: 2

   ->  Parallel Hash Join  (cost=157020.77..411442.97 rows=1165535 width=40) (actual time=13501.936..15610.047 rows=2 loops=3)

         Output: b.book_date, t.passenger_name, tf.fare_conditions, fl.scheduled_departure

         Inner Unique: true

         Hash Cond: (tf.flight_id = fl.flight_id)

         Join Filter: (date_trunc('day'::text, b.book_date) > date_bin('6 days'::interval, fl.scheduled_departure, ('2001-01-01 00:00:00'::timestamp without time zone)::timestamp with time zone))

         Rows Removed by Join Filter: 2797282

         Worker 0:  actual time=12088.479..15587.261 rows=3 loops=1

           JIT:

             Functions: 28

             Options: Inlining true, Optimization true, Expressions true, Deforming true

             Timing: Generation 4.140 ms, Inlining 206.371 ms, Optimization 155.895 ms, Emission 167.726 ms, Total 534.132 ms

         Worker 1:  actual time=13249.700..15584.830 rows=1 loops=1

           JIT:

             Functions: 28

             Options: Inlining true, Optimization true, Expressions true, Deforming true

             Timing: Generation 12.240 ms, Inlining 131.843 ms, Optimization 229.014 ms, Emission 140.840 ms, Total 513.936 ms

         ->  Parallel Hash Join  (cost=150934.95..340924.45 rows=3496605 width=36) (actual time=6400.189..9700.103 rows=2797284 loops=3)

               Output: b.book_date, t.passenger_name, tf.fare_conditions, tf.flight_id

               Hash Cond: (tf.ticket_no = t.ticket_no)

               Worker 0:  actual time=6409.301..9698.229 rows=2641036 loops=1

               Worker 1:  actual time=6402.482..9699.195 rows=2869102 loops=1

               ->  Parallel Seq Scan on bookings.ticket_flights tf  (cost=0.00..104899.05 rows=3496605 width=26) (actual time=0.077..1047.981 rows=2797284 loops=3)

                     Output: tf.fare_conditions, tf.ticket_no, tf.flight_id

                     Worker 0:  actual time=0.077..1028.167 rows=2593932 loops=1

                     Worker 1:  actual time=0.099..1065.709 rows=2809680 loops=1

               ->  Parallel Hash  (cost=125968.63..125968.63 rows=1229066 width=38) (actual time=3430.192..3430.203 rows=983286 loops=3)

                     Output: b.book_date, t.passenger_name, t.ticket_no

                     Buckets: 65536  Batches: 64  Memory Usage: 3872kB

                     Worker 0:  actual time=3427.889..3427.899 rows=1024935 loops=1

                     Worker 1:  actual time=3435.314..3435.322 rows=826541 loops=1

                     ->  Parallel Hash Join  (cost=37534.65..125968.63 rows=1229066 width=38) (actual time=1693.882..2762.844 rows=983286 loops=3)

                           Output: b.book_date, t.passenger_name, t.ticket_no

                           Inner Unique: true

                           Hash Cond: (t.book_ref = b.book_ref)

                           Worker 0:  actual time=1706.886..2751.491 rows=1024935 loops=1

                           Worker 1:  actual time=1690.315..2740.740 rows=826541 loops=1

                           ->  Parallel Seq Scan on bookings.tickets t  (cost=0.00..61705.66 rows=1229066 width=37) (actual time=0.075..457.926 rows=983286 loops=3)

                                 Output: t.passenger_name, t.book_ref, t.ticket_no

                                 Worker 0:  actual time=0.067..447.778 rows=971374 loops=1

                                 Worker 1:  actual time=0.096..483.976 rows=1056968 loops=1

                           ->  Parallel Hash  (cost=22243.29..22243.29 rows=879629 width=15) (actual time=602.002..602.004 rows=703703 loops=3)

                                 Output: b.book_date, b.book_ref

                                 Buckets: 131072  Batches: 64  Memory Usage: 2592kB

                                 Worker 0:  actual time=601.727..601.728 rows=770242 loops=1

                                 Worker 1:  actual time=600.970..600.971 rows=776208 loops=1

                                 ->  Parallel Seq Scan on bookings.bookings b  (cost=0.00..22243.29 rows=879629 width=15) (actual time=0.042..241.068 rows=703703 loops=3)

                                       Output: b.book_date, b.book_ref

                                       Worker 0:  actual time=0.055..253.960 rows=770242 loops=1

                                       Worker 1:  actual time=0.046..252.107 rows=776208 loops=1

         ->  Parallel Hash  (cost=3887.92..3887.92 rows=126392 width=12) (actual time=569.356..569.357 rows=71622 loops=3)

               Output: fl.scheduled_departure, fl.flight_id

               Buckets: 131072  Batches: 4  Memory Usage: 3616kB

               Worker 0:  actual time=549.057..549.058 rows=16550 loops=1

               Worker 1:  actual time=547.063..547.063 rows=33467 loops=1

               ->  Parallel Seq Scan on bookings.flights fl  (cost=0.00..3887.92 rows=126392 width=12) (actual time=518.189..537.553 rows=71622 loops=3)

                     Output: fl.scheduled_departure, fl.flight_id

                     Worker 0:  actual time=530.406..534.852 rows=16550 loops=1

                     Worker 1:  actual time=502.092..517.949 rows=33467 loops=1

Planning Time: 20.794 ms

JIT:

   Functions: 84

   Options: Inlining true, Optimization true, Expressions true, Deforming true

   Timing: Generation 18.821 ms, Inlining 448.342 ms, Optimization 697.145 ms, Emission 407.539 ms, Total 1571.846 ms

Execution Time: 15980.773 ms

(68 rows)

                                                                          

```

**Анализ:** Для выполнения запроса используется JIT-компиляция, для объединения таблиц в запросе используется механизм параллельного слияния хэшированием.

 

### 3.6 К работе приложить структуру таблиц, для которых выполнялись соединения

![Alt text](https://postgrespro.ru/media/docs/postgrespro/9.6/ru/demodb-bookings-schema.svg "Структура таблиц тестовой БД")

 

### 3.7 Материалы

 

<https://habr.com/ru/company/postgrespro/blog/574702/>

<https://postgrespro.ru/education/courses/QPT>

 

## 4. Придумайте 3 своих метрики на основе показанных представлений, отправьте их через ЛК, а так же поделитесь с коллегами в слаке

### 4.1 Выборка 5 самых медленных запросов для заданной БД.

```sql

select pgdb.datname, pgstat.* from pg_database pgdb inner join pg_stat_statements pgstat on pgdb.oid=pgstat.dbid

and pgdb.datname = 'demo'

order by total_exec_time desc limit 5;

 

-[ RECORD 1 ]-------+---------------------------------------------------------------------------------------------------------------------------------------------------------

datname             | demo

userid              | 10

dbid                | 16384

toplevel            | t

queryid             | -4855699836368978498

query               | select b.book_date, t.passenger_name, tf.fare_conditions, fl.scheduled_departure  from bookings b inner join tickets t on b.book_ref = t.book_ref       +

                    | inner join ticket_flights tf on t.ticket_no = tf.ticket_no                                                                                              +

                    | left join flights fl on date_trunc($1, b.book_date) > date_bin($2, fl.scheduled_departure, TIMESTAMP $3)                                                +

                    | where tf.flight_id = fl.flight_id

plans               | 0

total_plan_time     | 0

min_plan_time       | 0

max_plan_time       | 0

mean_plan_time      | 0

stddev_plan_time    | 0

calls               | 1

total_exec_time     | 14623.710059000001

min_exec_time       | 14623.710059000001

max_exec_time       | 14623.710059000001

mean_exec_time      | 14623.710059000001

stddev_exec_time    | 0

rows                | 6

shared_blks_hit     | 142

shared_blks_read    | 135419

shared_blks_dirtied | 0

shared_blks_written | 0

local_blks_hit      | 0

local_blks_read     | 0

local_blks_dirtied  | 0

local_blks_written  | 0

temp_blks_read      | 159528

temp_blks_written   | 160756

blk_read_time       | 0

blk_write_time      | 0

wal_records         | 0

wal_fpi             | 0

wal_bytes     

...

```

### 4.2 Выборка 5 самых популярных запросов для заданной БД .

```sql

select pgdb.datname, pgstat.* from pg_database pgdb inner join pg_stat_statements pgstat on pgdb.oid=pgstat.dbid

and pgdb.datname = 'demo'

order by calls desc limit 5;

 

-[ RECORD 1 ]-------+---------------------------------------------------------------------------------------------------------------------------------------------------------

datname             | demo

userid              | 10

dbid                | 16384

toplevel            | t

queryid             | 7951185653172872331

query               | select * from pg_database pgdb inner join pg_stat_statements pgstat on pgdb.oid=pgstat.dbid and pgdb.datname = $1 order by total_exec_time desc limit $2

plans               | 0

total_plan_time     | 0

min_plan_time       | 0

max_plan_time       | 0

mean_plan_time      | 0

stddev_plan_time    | 0

calls               | 3

total_exec_time     | 0.572513

min_exec_time       | 0.179932

max_exec_time       | 0.197654

mean_exec_time      | 0.19083766666666668

stddev_exec_time    | 0.007791418627067991

rows                | 19

shared_blks_hit     | 3

shared_blks_read    | 0

shared_blks_dirtied | 0

shared_blks_written | 0

local_blks_hit      | 0

local_blks_read     | 0

local_blks_dirtied  | 0

local_blks_written  | 0

temp_blks_read      | 0

temp_blks_written   | 0

blk_read_time       | 0

blk_write_time      | 0

wal_records         | 0

wal_fpi             | 0

wal_bytes           | 0

...

```

 

### 4.3 Выборка неиспользуемых индексов

```sql

select relname, indexrelname from pg_stat_user_indexes where idx_scan = 0;

 

-[ RECORD 1 ]+------------------------------------------

relname      | boarding_passes

indexrelname | boarding_passes_flight_id_boarding_no_key

-[ RECORD 2 ]+------------------------------------------

relname      | seats

indexrelname | seats_pkey

```